
================================================================================
 GNARLY
================================================================================

This project is an attempt at a UDP network library. Primarily aimed at games.

Very much /work in progress/.

See network/README for a detailed overview of how each packet is constructed.
See client/README and the client code for an example of how it all works.

================================================================================
 FEATURES
================================================================================

- Full IPv4 and IPv6 support
- NAT client resolution: Multiple clients connecting from behind a NAT router
  and sharing the same public IP can accurately be identified.

- Packet compression and encryption can be enabled/disabled.
  You can set (de)compression and (en/de)cryption handlers if you wish to use
  your own versions of either of these. Note that compression and encryption
  operates on the full dataset supplied to the Send routine. Any data that
  requires fragmentation is compressed/encrypted as a whole and then cut into
  smaller chunks. The library will reassemble the packets on the receiving end
  and only then decompress/decrypt it all.

- Customizable packet size limit. Defaults to 1400 bytes. This includes the
  22 byte UDP header and a 5 or 7 byte (depending on which flags are set) header
  we use in this library internally.

- Latency tracking for 'connected' peers as well as a timeout mechanism based on
  a customizable timeout value. Both newly connecting peers and those that
  time out generate messages you can intercept and act on. Refer to
  client/client.go to see how this works. This operates by sending PING packets
  to known peers at regular (customizable) intervals.

- Supports packet fragmentation. If a chunk of data you want to send exceeds
  the maximum packet size, the library will automatically create multiple
  sequentially tagged packets and has the ability to cache them on the receiving
  end in order to reconstruct the original data. This mechanism also guarantees
  that the multi-packet dataset is rebuilt in the correct order.
 
  All if this is completely transparent to the host application. All it will
  deal with is sending any arbitrarilly sized chunk of data and receive it on
  the other end. It will never know how many packets where involved. It gets
  a 'network.Message' struct instance containing the entire dataset and the
  Md5 hash identifying the sender.

================================================================================
TODO
================================================================================

- Implement our own default compression and encryption routines. Currently these
  are just empty placeholder functions. The mechanism to make these work on
  packets is in place and operational; these functions just need something to
  do.

- Implement proper ACK packets. Ideally these should piggyback on other packets.

- Resolve local (NAT/LAN) ip address for a client. This is needed to calculate
  the 2 byte clientid. Currently the Go network lib only yields the loopback
  address when resolving the hostname. We need to get it to spit out the DHCP
  address if any. Possibly by querying the network interfaces directly.
  
  The client program requires us to specify this local IP manually through a 
  commandline parameter. This is obviously not desirable.

--------------------------------------------------------------------------------
 USAGE
--------------------------------------------------------------------------------

 In order to start using this repository, make sure you have the latest Go
 buildtools installed and follow these steps:

 $ cd /path/to/codelib
 $ git clone http://github.com/jteeuwen/gnarly.git
 $ cd gnarly
 $ make

--------------------------------------------------------------------------------
 LICENSE
--------------------------------------------------------------------------------

This code is subject to a 1-clause BSD license.
The contents of which can be found in the LICENSE file.

